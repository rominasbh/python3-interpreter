/**
 * @file parser.cpp
 * @brief Implementation of the Parser class.
 * 
 * This file implements the Parser class, which takes a sequence of tokens generated by the Lexer and constructs
 * an abstract syntax tree (AST) representing the source code's structure. This AST can then be interpreted or
 * compiled by other components of the interpreter. The Parser handles syntax according to a predefined grammar,
 * converting linear token sequences into hierarchical structures that represent the program's logical and
 * syntactical structure.
 * 
 * Major components implemented in this file include:
 * - `Parser::parse()`: Parses the tokens into a BlockStmt, which is the root of the AST for the given source.
 * - `Parser::parseStatement()`: Parses individual statements, including variable assignments, print statements, and
 *   if statements, creating the corresponding AST nodes.
 * - `Parser::parseExpression()`: Parses expressions, including binary operations and comparisons, and constructs the
 *   corresponding expression AST nodes.
 * 
 * The parser supports basic control structures like if-else statements and variable assignments. Expressions can
 * include arithmetic operations, variable references, and literals. The parser is designed to follow the principles
 * of recursive descent parsing, breaking down the parsing process into smaller functions that handle specific
 * parts of the grammar.
 * 
 * Usage:
 * After tokenizing the input source code with Lexer, create a Parser instance with the tokens and call `parse()`
 * to build the AST. This AST can then be interpreted to execute the program.
 * 
 */


#include "Parser.hpp"
#include "Interpreter.hpp"
#include "Utilities.hpp"
#include "Env.hpp"
#include <iostream>


struct ReturnValue;  // Forward declaration


AssignStmt::AssignStmt(const std::string& name, std::unique_ptr<Expr> value) : name(name), value(std::move(value)) {}

void AssignStmt::execute(Interpreter& interpreter, Environment& env)  {
        int val = value->evaluate(env); // Evaluate the expression with the given environment
        env.define(name, val); // Define or update the variable in the environment
        
    }


BlockStmt::BlockStmt(std::vector<std::unique_ptr<Stmt>> statements) : statements(std::move(statements)) {}

void BlockStmt::execute(Interpreter& interpreter, Environment& env)  {
        // Create a new environment for this block, with the current environment as its parent.
        Environment blockEnvironment(&env);

        for (auto& stmt : statements) {
            // Execute each statement within the block using the new scoped environment.
            stmt->execute(interpreter, blockEnvironment);
        }

        // The blockEnvironment goes out of scope here, along with any variables defined within the block.
        // Merge changes back to the parent environment
        env.mergeChanges(blockEnvironment);
      
    }
    
    void IfStmt::execute(Interpreter& interpreter, Environment& env) {
    // Evaluate the condition
    bool conditionValue = condition->evaluate(env);  
    

    if (conditionValue) {
        // If the condition is true, execute the actions associated with the condition.

        ifBranch->execute(interpreter, env); 
    } else if (elseBranch != nullptr) {
        // If the condition is false and there is an else branch, execute the else branch.
        elseBranch->execute(interpreter, env);
    }
    // If there's no else branch, nothing happens when the condition is false.
}

void ReturnStmt::execute(Interpreter& interpreter, Environment& env) {
    int value = returnValue ? interpreter.evaluateExpr(returnValue, env) : 0; // returning 0 if no expression
    throw ReturnValue(value); // pass return values
}

// Execute function in interpreter context
void FunctionStmt::execute(Interpreter& interpreter, Environment& env) {
    //captures the current function statement as a shared_ptr to store in the environment
    auto self = std::shared_ptr<FunctionStmt>(this, [](FunctionStmt*) {});
    interpreter.defineFunction(name, self);

}
int CallExpr::evaluate(Environment& env) {
        std::vector<int> argValues = convertArgumentsToValues(arguments, env);
        return interpreter.callFunction(functionName, argValues,env);
    }

void CallExpr::execute(Interpreter& interpreter, Environment& env) {

        evaluate(env);
    }




std::unique_ptr<Stmt> Parser::parse() {
    std::vector<std::unique_ptr<Stmt>> statements;
    while (!isAtEnd() && peek().type != TokenType::END_OF_FILE) {
        auto stmt = parseStatement();
        if (stmt != nullptr) {
            statements.push_back(std::move(stmt));
        }
    }
    // Return a single BlockStmt containing all statements
    return std::make_unique<BlockStmt>(std::move(statements));
}

std::unique_ptr<Expr> Parser::parsePrimary() {
    if (peek().type == TokenType::INTEGER) {
        int value = std::stoi(advance().lexeme);
        return std::make_unique<LiteralExpr>(value);
    } else if (peek().type == TokenType::STRING) {
        std::string value = advance().lexeme;
        return std::make_unique<StringLiteralExpr>(value);    
    } else if (peek().type == TokenType::IDENTIFIER) {
        std::string varName = advance().lexeme;
        if (match({TokenType::LPAREN})) {
            // Handle function call
            std::vector<std::unique_ptr<Expr>> arguments;
            if (!check(TokenType::RPAREN)) {
                do {
                    arguments.push_back(parseExpression());
                } while (match({TokenType::COMMA}));
            }
            consume(TokenType::RPAREN, "Expect ')' after arguments.");
            return std::make_unique<CallExpr>(varName, std::move(arguments),interpreter);
        } else {
            // It's a simple variable reference
            return std::make_unique<VarExpr>(varName);
        }
    }  else if (match({TokenType::LPAREN})) {
        auto expr = parseExpression();
        consume(TokenType::RPAREN, "Expect ')' after expression.");
        return expr;
    }

    throw std::runtime_error("UnExpected expression.");
}

std::unique_ptr<Expr> Parser::parseUnary() { 
    if (match({TokenType::MINUS})) {
        if (peek().type == TokenType::INTEGER)  {
            int value = -std::stoi(advance().lexeme); // Negate the integer value
            return std::make_unique<LiteralExpr>(value);
        }
    }
    return parsePrimary();
}


std::unique_ptr<Expr> Parser::parseFactor() {
    auto expr = parseUnary();
    while (match({TokenType::MUL, TokenType::DIV})) {
        Token op = previous();
        auto right = parseUnary();
        TokenType type = op.type;
        expr = std::make_unique<BinaryExpr>(std::move(expr), type, std::move(right));
    }
    return expr;
}

std::unique_ptr<Expr> Parser::parseTerm() {
    auto expr = parseFactor();
    while (match({TokenType::PLUS, TokenType::MINUS})) {
        Token op = previous();
        auto right = parseFactor();
        TokenType type = op.type;
        expr = std::make_unique<BinaryExpr>(std::move(expr), type, std::move(right));
    }
    return expr;
}

std::unique_ptr<Expr> Parser::parseComparison() {
    auto expr = parseTerm();
    while (match({TokenType::EQUAL, TokenType::NOT_EQUAL, TokenType::GREATER, TokenType::LESS, TokenType::GREATER_EQUAL, TokenType::LESS_EQUAL})) {
        Token op = previous();
        auto right = parseTerm();
        expr = std::make_unique<BinaryExpr>(std::move(expr), op.type, std::move(right));
    }

    return expr;
}


std::unique_ptr<Expr> Parser::parseExpression() {
    return parseComparison(); // Starting point for expression parsing
    throw std::runtime_error("Unexpected token in expression");
}

std::unique_ptr<Stmt> Parser::parseStatement() {
    if (match({TokenType::PRINT})) {
        return parsePrintStatement();
    } else if (match({TokenType::IDENTIFIER})) {
        // Save the identifier token for later use
        Token variableName = previous();
        consume(TokenType::ASSIGN, "Expect '=' after variable name.");
        auto value = parseExpression(); // Parse the right-hand side expression 
        return std::make_unique<AssignStmt>(variableName.lexeme, std::move(value));
    }
    else if (match({TokenType::IF})){
        return parseIfStatement();
    }
    else if (match({TokenType::DEF})) {
        return parseFunctionDefinition();
    }
    throw std::runtime_error("Unexpected token in statement");
    
}
std::unique_ptr<Stmt> Parser::parseIfStatement() {
    auto condition = parseExpression();
    consume(TokenType::COLON, "Expect ':' after if condition.");
    auto ifBranch = parseBlock();
    std::unique_ptr<Stmt> elseBranch = nullptr;

    if (match({TokenType::ELSE})) {
        consume(TokenType::COLON, "Expect ':' after else.");
        elseBranch = parseBlock();
    }
    return std::make_unique<IfStmt>(std::move(condition), std::move(ifBranch), std::move(elseBranch));
}


std::unique_ptr<Stmt> Parser::parseBlock() {
    std::vector<std::unique_ptr<Stmt>> blockStatements;
    consume(TokenType::INDENT, "Expected indent at the start of a new block.");
    while (!check(TokenType::DEDENT) && !isAtEnd()) {
        try {
            blockStatements.push_back(parseStatement());
        } catch (const std::runtime_error& e) {
            std::cerr << "Error parsing statement in block: " << e.what() << std::endl;
            // Skip to the end of the statement or synchronize
            synchronize();
        }
    }
    consume(TokenType::DEDENT, "Expected dedent at the end of the block.");

    return std::make_unique<BlockStmt>(std::move(blockStatements));
}

void Parser::synchronize() {
    while (!isAtEnd()) {
        switch (peek().type) {
            case TokenType::NEWLINE:
                advance();  // Consume the newline and check the next token
                break;
            case TokenType::INDENT:
            case TokenType::DEDENT:
                // Indent and Dedent are significant for block structure
                return;
            case TokenType::IF:
            case TokenType::ELSE:
                return;
            default:
                advance();  // Continue to skip tokens until reaching a significant one
                break;
        }
    }
}




std::unique_ptr<Stmt> Parser::parsePrintStatement() {
    consume(TokenType::LPAREN, "Expect '(' after 'print'.");
    std::vector<std::unique_ptr<Expr>> expressions;

    if (!check(TokenType::RPAREN)) {
        do {
            expressions.push_back(parseExpression());

        } while (match({TokenType::COMMA}));
    }
    
    consume(TokenType::RPAREN, "Expect ')' after arguments.");
    return std::make_unique<PrintStmt>(std::move(expressions));
}

std::unique_ptr<Stmt> Parser::parseFunctionDefinition() {
    auto functionName = advance().lexeme;
    // Parse parameters
    consume(TokenType::LPAREN, "Expect '(' after function name.");
    std::vector<std::string> parameters;
    if (!check(TokenType::RPAREN)) { // Check if there are any parameters
        do {
            parameters.push_back(advance().lexeme);
        } while (match({TokenType::COMMA}));
    }
    consume(TokenType::RPAREN, "Expect ')' after parameters.");
    consume(TokenType::COLON, "Expect ':' after parameter list.");

    // Handle indentation
    consume(TokenType::INDENT, "Expect an indentation after function header.");

    std::vector<std::unique_ptr<Stmt>> body;
    while (!check(TokenType::DEDENT) && !isAtEnd()) {
        if (match({TokenType::RETURN})) {
            body.push_back(parseReturnStatement());
            break;  // stop parsing after return 
        } else {
            body.push_back(parseStatement());
        }
    }

    // Handle dedentation
    consume(TokenType::DEDENT, "Expect dedentation at the end of function block.");

    return std::make_unique<FunctionStmt>(functionName, std::move(parameters), std::make_unique<BlockStmt>(std::move(body)));
}


std::unique_ptr<Stmt> Parser::parseReturnStatement() {

    auto value = parseExpression();  // Assume return is followed by an expression
    return std::make_unique<ReturnStmt>(std::move(value));
}

std::unique_ptr<Expr> Parser::parseFunctionCall(const std::string& functionName) {
    std::vector<std::unique_ptr<Expr>> arguments;
    if (!check(TokenType::RPAREN)) {  // If there are arguments
        do {
            arguments.push_back(parseExpression());
        } while (match({TokenType::COMMA}));
    }
    consume(TokenType::RPAREN, "Expect ')' after arguments.");
    return std::make_unique<CallExpr>(functionName, std::move(arguments),interpreter);
}
