/**
 * @file parser.cpp
 * @brief Implementation of the Parser class.
 * 
 * This file implements the Parser class, which takes a sequence of tokens generated by the Lexer and constructs
 * an abstract syntax tree (AST) representing the source code's structure. This AST can then be interpreted or
 * compiled by other components of the interpreter. The Parser handles syntax according to a predefined grammar,
 * converting linear token sequences into hierarchical structures that represent the program's logical and
 * syntactical structure.
 * 
 * Major components implemented in this file include:
 * - `Parser::parse()`: Parses the tokens into a BlockStmt, which is the root of the AST for the given source.
 * - `Parser::parseStatement()`: Parses individual statements, including variable assignments, print statements, and
 *   if statements, creating the corresponding AST nodes.
 * - `Parser::parseExpression()`: Parses expressions, including binary operations and comparisons, and constructs the
 *   corresponding expression AST nodes.
 * 
 * The parser supports basic control structures like if-else statements and variable assignments. Expressions can
 * include arithmetic operations, variable references, and literals. The parser is designed to follow the principles
 * of recursive descent parsing, breaking down the parsing process into smaller functions that handle specific
 * parts of the grammar.
 * 
 * Usage:
 * After tokenizing the input source code with Lexer, create a Parser instance with the tokens and call `parse()`
 * to build the AST. This AST can then be interpreted to execute the program.
 * 
 */


#include "Parser.hpp"
#include "Interpreter.hpp"
#include "Utilities.hpp"
#include "Env.hpp"
#include <iostream>




AssignStmt::AssignStmt(const std::string& name, std::unique_ptr<Expr> value) : name(name), value(std::move(value)) {}

void AssignStmt::execute(Interpreter& interpreter, Environment& env)  {
        int val = value->evaluate(env); // Evaluate the expression with the given environment
        env.define(name, val); // Define or update the variable in the environment
        //line added for debugging
        std::cout << "Assigning: " << name << " = " << val << std::endl;
    }


BlockStmt::BlockStmt(std::vector<std::unique_ptr<Stmt>> statements) : statements(std::move(statements)) {}

void BlockStmt::execute(Interpreter& interpreter, Environment& env)  {
        // Create a new environment for this block, with the current environment as its parent.
        Environment blockEnvironment(&env);

        for (auto& stmt : statements) {
            // Execute each statement within the block using the new scoped environment.
            stmt->execute(interpreter, blockEnvironment);
        }

        // The blockEnvironment goes out of scope here, along with any variables defined within the block.
        // Merge changes back to the parent environment (if necessary).
        env.mergeChanges(blockEnvironment);
        //line added for scope debugging
        std::cout << "Exiting block environment, variables preserved in parent environment." << std::endl;
    }
    
    void IfStmt::execute(Interpreter& interpreter, Environment& env) {
    // Evaluate the condition
    bool conditionValue = condition->evaluate(env);
    //line added for debugging
    std::cout << "Condition evaluated to: " << (conditionValue ? "true" : "false") << std::endl;    
    

    if (conditionValue) {
        // If the condition is true, execute the actions associated with the condition.

        ifBranch->execute(interpreter, env); 
    } else if (elseBranch != nullptr) {
        // If the condition is false and there is an else branch, execute the else branch.
        elseBranch->execute(interpreter, env);
    }
    // If there's no else branch, nothing happens when the condition is false.
}




std::unique_ptr<Stmt> Parser::parse() {
    std::vector<std::unique_ptr<Stmt>> statements;
    while (!isAtEnd() && peek().type != TokenType::END_OF_FILE) {
        auto stmt = parseStatement();
        if (stmt != nullptr) {
            statements.push_back(std::move(stmt));
        }
    }
    // Return a single BlockStmt containing all statements
    std::cout << "returned the block from parse " <<std::endl;
    return std::make_unique<BlockStmt>(std::move(statements));
}

std::unique_ptr<Expr> Parser::parsePrimary() {
    if (peek().type == TokenType::INTEGER) {
        int value = std::stoi(advance().lexeme);
        return std::make_unique<LiteralExpr>(value);
    } else if (peek().type == TokenType::STRING) {
        std::string value = advance().lexeme;
        return std::make_unique<StringLiteralExpr>(value);    
    } else if (peek().type == TokenType::IDENTIFIER) {
        // Create an expression that represents a variable usage
        std::string varName = advance().lexeme;
        return std::make_unique<VarExpr>(varName);
    } else if (match({TokenType::LPAREN})) {
        auto expr = parseExpression();
        consume(TokenType::RPAREN, "Expect ')' after expression.");
        return expr;
    }
    // Handle more primary expressions as needed...
    throw std::runtime_error("UnExpected expression.");
}

std::unique_ptr<Expr> Parser::parseUnary() { 
    if (match({TokenType::MINUS})) {
        if (peek().type == TokenType::INTEGER)  {
            int value = -std::stoi(advance().lexeme); // Negate the integer value
            return std::make_unique<LiteralExpr>(value);
        }
    }
    return parsePrimary();
}


std::unique_ptr<Expr> Parser::parseFactor() {
    auto expr = parseUnary();
    while (match({TokenType::MUL, TokenType::DIV})) {
        Token op = previous();
        auto right = parseUnary();
        TokenType type = op.type;
        expr = std::make_unique<BinaryExpr>(std::move(expr), type, std::move(right));
    }
    return expr;
}

std::unique_ptr<Expr> Parser::parseTerm() {
    auto expr = parseFactor();
    while (match({TokenType::PLUS, TokenType::MINUS})) {
        Token op = previous();
        auto right = parseFactor();
        TokenType type = op.type;
        expr = std::make_unique<BinaryExpr>(std::move(expr), type, std::move(right));
    }
    return expr;
}

std::unique_ptr<Expr> Parser::parseComparison() {
    auto expr = parseTerm();
    while (match({TokenType::EQUAL, TokenType::NOT_EQUAL, TokenType::GREATER, TokenType::LESS, TokenType::GREATER_EQUAL, TokenType::LESS_EQUAL})) {
        Token op = previous();
        auto right = parseTerm();
        expr = std::make_unique<BinaryExpr>(std::move(expr), op.type, std::move(right));
    }

    return expr;
}


std::unique_ptr<Expr> Parser::parseExpression() {
    return parseComparison(); // Starting point for expression parsing
    throw std::runtime_error("Unexpected token in expression");
}

std::unique_ptr<Stmt> Parser::parseStatement() {
    //for debugging 
    std::cout << "Parsing statement, next token: Type - " << peek().lexeme << ", Text - '" << peek().lexeme << "'" << std::endl;
    if (match({TokenType::PRINT})) {
        return parsePrintStatement();
    } else if (match({TokenType::IDENTIFIER})) {
        // Save the identifier token for later use
        Token variableName = previous();
        //debug
        std::cout << "Processing assignment for variable: " << variableName.lexeme << std::endl;
        consume(TokenType::ASSIGN, "Expect '=' after variable name.");
        auto value = parseExpression(); // Parse the right-hand side expression 
        return std::make_unique<AssignStmt>(variableName.lexeme, std::move(value));
    }
    else if (match({TokenType::IF})){
        return parseIfStatement();
    }
    //     auto condition = parseExpression();
    //     consume(TokenType::COLON, "Expect ':' after if condition.");
    //     // auto ifBranch = parseStatement();
    //     auto ifBranch = parseBlock();  // Parse the entire block as 'if' branch
    //     std::unique_ptr<Stmt> elseBranch = nullptr;

    //     if (match({TokenType::ELSE})) {
    //         consume(TokenType::COLON, "Expect ':' after else.");
    //         // elseBranch = parseStatement();
    //         elseBranch = parseBlock();  // Parse the entire block as 'else' branch
    //     }      
    //     return std::make_unique<IfStmt>(std::move(condition),std::move(ifBranch), std::move(elseBranch));  
    // }
    throw std::runtime_error("Unexpected token in statement");
    
}
std::unique_ptr<Stmt> Parser::parseIfStatement() {
    auto condition = parseExpression();
    consume(TokenType::COLON, "Expect ':' after if condition.");
    auto ifBranch = parseBlock();
    std::unique_ptr<Stmt> elseBranch = nullptr;

    if (match({TokenType::ELSE})) {
        consume(TokenType::COLON, "Expect ':' after else.");
        elseBranch = parseBlock();
    }
    return std::make_unique<IfStmt>(std::move(condition), std::move(ifBranch), std::move(elseBranch));
}

//add this to treat the entire if as a block 
// std::unique_ptr<Stmt> Parser::parseBlock() {
//     std::vector<std::unique_ptr<Stmt>> blockStatements;
//     int blockIndentationLevel = getCurrentIndentationLevel(); 

//     while (!isAtEnd() && getCurrentIndentationLevel() == blockIndentationLevel) {
//         auto statement = parseStatement();
//         blockStatements.push_back(std::move(statement));
//     }

//     return std::make_unique<BlockStmt>(std::move(blockStatements));
// }
// std::unique_ptr<Stmt> Parser::parseBlock() {
//     std::vector<std::unique_ptr<Stmt>> blockStatements;

//     if(match({TokenType::INDENT})){

//         while (!check(TokenType::DEDENT) && !isAtEnd()) {
//             blockStatements.push_back(parseStatement());
//         }
//         consume(TokenType::DEDENT,"Expect indentation level -1 " );
//     }
//     // expect(TokenType::INDENT);
//     // while (!check(TokenType::DEDENT) && !isAtEnd()) {
//     //     blockStatements.push_back(parseStatement());
//     // }
//     // expect(TokenType::DEDENT);

//     return std::make_unique<BlockStmt>(std::move(blockStatements));
// }
std::unique_ptr<Stmt> Parser::parseBlock() {
    std::vector<std::unique_ptr<Stmt>> blockStatements;
    //debug statement 
    std::cerr << "start parsing the block" << std::endl;
    consume(TokenType::INDENT, "Expected indent at the start of a new block.");
    while (!check(TokenType::DEDENT) && !isAtEnd()) {
        try {
            blockStatements.push_back(parseStatement());
        } catch (const std::runtime_error& e) {
            std::cerr << "Error parsing statement in block: " << e.what() << std::endl;
            // Skip to the end of the statement or synchronize
            synchronize();
        }
    }
    std::cerr << "consuming ddent" << peek().lexeme << std::endl;
    consume(TokenType::DEDENT, "Expected dedent at the end of the block.");

    return std::make_unique<BlockStmt>(std::move(blockStatements));
}

void Parser::synchronize() {
    while (!isAtEnd()) {
        switch (peek().type) {
            case TokenType::NEWLINE:
                advance();  // Consume the newline and check the next token
                break;
            case TokenType::INDENT:
            case TokenType::DEDENT:
                // Indent and Dedent are significant for block structure
                return;
            case TokenType::IF:
            case TokenType::ELSE:
                return;
            // case TokenType::FOR:
            // case TokenType::WHILE:
            // case TokenType::DEF:
            // case TokenType::CLASS:
            // case TokenType::TRY:
            //     // These keywords start new blocks or statements
            //     return;
            default:
                advance();  // Continue to skip tokens until reaching a significant one
                break;
        }
    }
}




std::unique_ptr<Stmt> Parser::parsePrintStatement() {
    consume(TokenType::LPAREN, "Expect '(' after 'print'.");
    std::vector<std::unique_ptr<Expr>> expressions;
    //line added for debugging
    std::cout << "Parsing print statement." << std::endl;

    if (!check(TokenType::RPAREN)) {
        do {
            expressions.push_back(parseExpression());

        } while (match({TokenType::COMMA}));
    }
    
    consume(TokenType::RPAREN, "Expect ')' after arguments.");
    return std::make_unique<PrintStmt>(std::move(expressions));
}

std::unique_ptr<Stmt> Psrser::parseFunctionDefinition() {
    // Parse the function name, parameters
    // Parse the function body as a block statement
    // Return a function definition statement
}

