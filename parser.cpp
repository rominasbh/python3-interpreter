/**
 * @file parser.cpp
 * @brief Implementation of the Parser class.
 * 
 * This file implements the Parser class, which takes a sequence of tokens generated by the Lexer and constructs
 * an abstract syntax tree (AST) representing the source code's structure. This AST can then be interpreted or
 * compiled by other components of the interpreter. The Parser handles syntax according to a predefined grammar,
 * converting linear token sequences into hierarchical structures that represent the program's logical and
 * syntactical structure.
 * 
 * Major components implemented in this file include:
 * - `Parser::parse()`: Parses the tokens into a BlockStmt, which is the root of the AST for the given source.
 * - `Parser::parseStatement()`: Parses individual statements, including variable assignments, print statements, and
 *   if statements, creating the corresponding AST nodes.
 * - `Parser::parseExpression()`: Parses expressions, including binary operations and comparisons, and constructs the
 *   corresponding expression AST nodes.
 * 
 * The parser supports basic control structures like if-else statements and variable assignments. Expressions can
 * include arithmetic operations, variable references, and literals. The parser is designed to follow the principles
 * of recursive descent parsing, breaking down the parsing process into smaller functions that handle specific
 * parts of the grammar.
 * 
 * Usage:
 * After tokenizing the input source code with Lexer, create a Parser instance with the tokens and call `parse()`
 * to build the AST. This AST can then be interpreted to execute the program.
 * 
 */


#include "Parser.hpp"
#include "Interpreter.hpp"
#include "Utilities.hpp"
#include "Env.hpp"
#include <iostream>




AssignStmt::AssignStmt(const std::string& name, std::unique_ptr<Expr> value) : name(name), value(std::move(value)) {}

void AssignStmt::execute(Interpreter& interpreter, Environment& env)  {
        int val = value->evaluate(env); // Evaluate the expression with the given environment
        env.define(name, val); // Define or update the variable in the environment
    }


BlockStmt::BlockStmt(std::vector<std::unique_ptr<Stmt>> statements) : statements(std::move(statements)) {}

void BlockStmt::execute(Interpreter& interpreter, Environment& env)  {
        // Create a new environment for this block, with the current environment as its parent.
        Environment blockEnvironment(&env);

        for (auto& stmt : statements) {
            // Execute each statement within the block using the new scoped environment.
            stmt->execute(interpreter, blockEnvironment);
        }

        // The blockEnvironment goes out of scope here, along with any variables defined within the block.
    }
    void IfStmt::execute(Interpreter& interpreter, Environment& env) {
    // Evaluate the condition
    bool conditionValue = condition->evaluate(env);
    

    if (conditionValue) {
        // If the condition is true, execute the actions associated with the condition.

        ifBranch->execute(interpreter, env); 
    } else if (elseBranch != nullptr) {
        // If the condition is false and there is an else branch, execute the else branch.
        elseBranch->execute(interpreter, env);
    }
    // If there's no else branch, nothing happens when the condition is false.
}




std::unique_ptr<Stmt> Parser::parse() {
    std::vector<std::unique_ptr<Stmt>> statements;
    while (!isAtEnd() && peek().type != TokenType::END_OF_FILE) {
        auto stmt = parseStatement();
        if (stmt != nullptr) {
            statements.push_back(std::move(stmt));
        }
    }
    // Return a single BlockStmt containing all statements
    return std::make_unique<BlockStmt>(std::move(statements));
}

std::unique_ptr<Expr> Parser::parsePrimary() {
    if (peek().type == TokenType::INTEGER) {
        int value = std::stoi(advance().lexeme);
        return std::make_unique<LiteralExpr>(value);
    } else if (peek().type == TokenType::STRING) {
        std::string value = advance().lexeme;
        return std::make_unique<StringLiteralExpr>(value);    
    } else if (peek().type == TokenType::IDENTIFIER) {
        // Create an expression that represents a variable usage
        std::string varName = advance().lexeme;
        return std::make_unique<VarExpr>(varName);
    } else if (match({TokenType::LPAREN})) {
        auto expr = parseExpression();
        consume(TokenType::RPAREN, "Expect ')' after expression.");
        return expr;
    }
    // Handle more primary expressions as needed...
    throw std::runtime_error("UnExpected expression.");
}

std::unique_ptr<Expr> Parser::parseUnary() {
    if (match({TokenType::MINUS})) {
        if (peek().type == TokenType::INTEGER)  {
            int value = -std::stoi(advance().lexeme); // Negate the integer value
            return std::make_unique<LiteralExpr>(value);
        }
    }
    return parsePrimary();
}


std::unique_ptr<Expr> Parser::parseFactor() {
    auto expr = parseUnary();
    while (match({TokenType::MUL, TokenType::DIV})) {
        Token op = previous();
        auto right = parseUnary();
        TokenType type = op.type;
        expr = std::make_unique<BinaryExpr>(std::move(expr), type, std::move(right));
    }
    return expr;
}

std::unique_ptr<Expr> Parser::parseTerm() {
    auto expr = parseFactor();
    while (match({TokenType::PLUS, TokenType::MINUS})) {
        Token op = previous();
        auto right = parseFactor();
        TokenType type = op.type;
        expr = std::make_unique<BinaryExpr>(std::move(expr), type, std::move(right));
    }
    return expr;
}

std::unique_ptr<Expr> Parser::parseComparison() {
    auto expr = parseTerm();
    while (match({TokenType::EQUAL, TokenType::NOT_EQUAL, TokenType::GREATER, TokenType::LESS, TokenType::GREATER_EQUAL, TokenType::LESS_EQUAL})) {
        Token op = previous();
        auto right = parseTerm();
        expr = std::make_unique<BinaryExpr>(std::move(expr), op.type, std::move(right));
    }

    return expr;
}


std::unique_ptr<Expr> Parser::parseExpression() {
    return parseComparison(); // Starting point for expression parsing
    throw std::runtime_error("Unexpected token in expression");
}

std::unique_ptr<Stmt> Parser::parseStatement() {
    if (match({TokenType::PRINT})) {
        return parsePrintStatement();
    } else if (match({TokenType::IDENTIFIER})) {
        // Save the identifier token for later use
        Token variableName = previous();
        consume(TokenType::ASSIGN, "Expect '=' after variable name.");
        auto value = parseExpression(); // Parse the right-hand side expression 
        return std::make_unique<AssignStmt>(variableName.lexeme, std::move(value));
    }
    else if (match({TokenType::IF})){
        auto condition = parseExpression();
        consume(TokenType::COLON, "Expect ':' after if condition.");
        auto ifBranch = parseStatement();
        std::unique_ptr<Stmt> elseBranch = nullptr;
        if (match({TokenType::ELSE})) {
            consume(TokenType::COLON, "Expect ':' after else.");
            elseBranch = parseStatement();
        }      
        return std::make_unique<IfStmt>(std::move(condition),std::move(ifBranch), std::move(elseBranch));  
    }
    throw std::runtime_error("Unexpected token in statement");
    
}

std::unique_ptr<Stmt> Parser::parsePrintStatement() {
    consume(TokenType::LPAREN, "Expect '(' after 'print'.");
    std::vector<std::unique_ptr<Expr>> expressions;

    if (!check(TokenType::RPAREN)) {
        do {
            expressions.push_back(parseExpression());

        } while (match({TokenType::COMMA}));
    }
    
    consume(TokenType::RPAREN, "Expect ')' after arguments.");
    return std::make_unique<PrintStmt>(std::move(expressions));
}



